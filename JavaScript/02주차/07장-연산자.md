07장 연산자 챕터 같은 경우는 09장에 나오는 타입 변환과 단축 평가와도 연관이 깊습니다.
모든 연산자를 이해하고 암기하려는 것보다, 특정 연산자를 사용했을 때 어떤 결과가 나오는지를 주목해서 봐주세요.

## 📌07장 학습목표

- 연산자가 무엇인지 설명할 수 있다.
- 연산자의 다양한 종류들과 각각의 특징에 대해서 설명할 수 있다.
- 부수 효과가 있는 연산자가 어떤 것인지 설명할 수 있다.

<br>

## 연산자(Operator)

> 피연산자를 연산(산술,할당,비교,논리,타입,지수 연산 등)하여 새로운 값을 만드는 역할을 수행하는 기호(symbol)입니다.

연산하다의 뜻은 '일정한 규칙에 따라 계산하다.'라는 뜻입니다. (calculate)

우리는 연산의 대상을 `피연산자(operand)`라고 합니다.

여기서 중요한 점은 **피연산자는 `값`으로 평가(해석)될 수 있는 표현식**이어야 한다는 점입니다.
(만약 연산하고자 하는 대상이 값이 아니라면 새로운 값을 만들 수 없겠죠?)

이제 연산자의 정의를 파악했으니, 자바스크립트가 제공하는 다양한 연산자에 대해서 알아봅시다.

<br>

## 산술 연산자(Arithmetic Operator)

> 수학적 계산을 수행해 새로운 숫자 값을 만듭니다. 불가능할 경우 NaN을 반환합니다.

산술 연산자는 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있습니다.

### 이항 산술 연산자

2개의 피연산자를 사용합니다. 피연산자의 값은 바뀌지 않고 새로운 값을 만들기만 합니다.

### 단항 산술 연산자

1개의 피연산자를 사용하여 숫자 값을 만듭니다.

단항 산술 연산자에서 가장 눈여겨 봐야할 연산자는 `증가/감소(++ / --) 연산자` 입니다.

왜냐하면 `증가/감소(++ / --)` 연산자는 **피연산자의 값을 변경하는 부수효과가 존재**하기 때문입니다.

가령, 피연산자를 `x`라고 했을 때, `x++` 같은 경우 `x=x+1`이기에 암묵적 할당이 이뤄지니까 당연히 피연산자의 값을 변경할 수 밖에 없겠죠.

```js
let x = 1,
  result;

//선할당 후증가(postfix increment operator)
result = x++;
console.log(result, x); //1 2

//선증가 후할당(prefix increment operator)
result = ++x;
console.log(result, x); //3 3

//선할당 후감소(postfix decrement operator)
result = x--;
console.log(result, x); //3 2

//선감소 후할당(prefix decrement operator)
result = --x;
console.log(result, x); //1 1
```

`+`단항 연산자 같은 경우에는 숫자 타입이 아닌 피연산자에 사용할 경우 숫자 타입으로 변환하여 반환한다는 점을 유의해서 봐주세요.
(`-` 단항 연산자의 경우에도 마찬가지입니다. 다만 부호가 반대로 나옵니다.)

```js
let x = "1";

// 문자열을 숫자로 타입을 변환합니다.
console.log(+x); // 1
// 부수 효과는 없습니다.
console.log(x); // "1"

// 불리언 값을 숫자로 타입 변환합니다.
x = true;
console.log(+x); // 1
// 부수 효과는 없습니다.
console.log(x); // true

// 불리언 값을 숫자로 타입 변환합니다.
x = false;
console.log(+x); // 0
// 부수 효과는 없습니다.
console.log(x); // false

// 숫자로 타입 변환을 할 수 없는 문자열 같은 경우 NaN을 반환합니다.
x = "Hi";
console.log(+x); // NaN
// 부수 효과는 없습니다.
console.log(x); //"Hi"
```

### 문자열 연결 연산자

`+` 연산자의 경우 `하나 이상이 문자열인 경우` 문자열 연결 연산자로 동작합니다. 그 외의 경우에는 산술 연산자로 동작합니다.

```js
//문자열 연결 연산자
"2" + 3; // "23"

// true는 1로 타입 변환 됩니다.
1 + true; // 2

// false는 0으로 타입 변환 됩니다.
1 + false; // 1

// null은 0으로 타입 변환 됩니다.
1 + null; // 1

// undefined는 숫자로 타입 변환이 되지 않습니다.
1 + undefined; // undefined
```

<br>

## 할당 연산자(Assignment Operator)

> 피연산자의 평가 결과를 변수에 할당합니다.

할당문은 표현식인 문이기에 `값`으로 평가됩니다.

따라서 할당문을 다른 변수에 할당 할 수 있기 때문에, `연쇄 할당`이 가능하다는 것만 알고 넘어가겠습니다.

```js
let x, y, z;

// 연쇄할당의 경우 오른쪽에서 왼쪽으로 진행됩니다.
// z = 1 : 1로 평가됩니다.
// y = 1 : 1로 평가됩니다.
// x = 1 : 1로 평가됩니다.
x = y = z = 1;

console.log(x, y, z);
```

<br>

## 비교 연산자(Comparison Operator)

> 좌항과 우항의 피연산자를 비교한 다음 그 결과를 **Boolean** 값으로 반환합니다.

헷갈리는 지점만 짚고 넘어가겠습니다.

먼저 동등 비교 연산자(==)는 비교할때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교합니다.

```js
// 암묵적 타입 변환을 통해 타입을 일치시키면 동등해집니다.
5 == "5"; // true
```

이처럼 동등 비교 연산자는( == )는 예측하기 어려운 결과를 만들기 때문에 **일치 비교 연산자(===)** 를 사용할 것을 권장합니다.

❗️예외 사항

```js
//NaN은 자신과 일치않는 유일한 값입니다.
NaN === NaN; // false
```

따라서 NaN인지를 조사하려면 빌트인 함수 `isNaN`을 사용해야합니다.

```js
// isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환합니다.

isNaN(NaN); // true

isNaN(1); // false

isNaN(2 + undefined); // true
```

참고로 ES6에 도입된 `Object.is` 메서드를 통해서 예측 가능한 정확한 비교 결과를 볼 수 있습니다.

```js
-0 === +0; //true
Object.is(-0, +0); //false

NaN === NaN; //false
Object.is(NaN, NaN); // true
```

<br>

## 삼항 조건 연산자(Ternary Operator)

> 조건식의 평가 결과에 따라 반환할 값을 결정합니다.

여기서 중요한 점은 `if...else` 구문과 차이점입니다.

`삼항 조건 연산자` 표현식은 값처럼 사용할 수 있지만, `if...else`문은 값처럼 사용할 수 없습니다.

그래서 삼항 조건 연산자가 유용한 점은 값처럼 **다른 표현식의 일부가 될 수 있다**는 점입니다.

```js
let x = 4;

let result  =if(x % 2){result = "홀수"} else{result= "짝수"} // 🚫SyntaxError
```

```js
let x = 4;

let result = x % 2 ? "홀수" : "짝수"; // ✅ 정상 작동

console.log(result); //짝수
```

<br>

## 논리 연산자

> 우항과 좌항의 피연산자를 논리 연산합니다.

```js

|| //논리합 (OR)
&& // 논리곱(AND)
! //부정(NOT)
```

<br>

## 쉼표 연산자(Comma Operator)

> 왼쪽 피연산자부터 차례대로 평가하고, 마지막 피연산자의 평가 결과를 반환합니다.

```js
let a, b, c;

(a = 1), (b = 2), (c = 3); // 3
```

<br>

## 그룹 연산자(Group Operator)

> 소괄호로 피연산자를 감싸 연산 우선순위를 가장 높게 평가합니다.

<br>

## typeof 연산자

> 피연산자의 데이터 타입을 **문자열**로 반환합니다.

한 가지 주의할 점은 `typeof` 연산자로 `null` 값을 연산하면 `object`로 반환합니다. (자바스크립트 🐞입니다.)

따라서 null 타입인지 확인할 때는 일치 연산자(===)를 사용해야합니다.

```js
//typeof로 null을 연산할 경우 object를 반환합니다.
typeof null; // object

// null 타입인지 확인할 때는 일치 연산자를 사용합시다.
let x = null;

x === null; //true
```

<br>

## 지수 연산자(Exponentiation Operator)

> ES7에 도입되어, 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱한 숫자 값을 반환합니다.

```js
let num = 10;

console.log(num ** 2); // 100
```

<br>

## 연산자의 부수효과

부수 효과가 있는 연산자는 다음과 같습니다.

- 할당 연산자
- 증가/감소 연산자(++/--)
- delete 연산자

```js
let x;

x = 2;
console.log(x); // 2

x++;
console.log(x); //3

//delete 연산자는 객체의 프로퍼티를 삭제하는 부수효과가 있습니다.
let obj = { a: 1 };
delete obj.a;
console.log(obj); // {}
```
