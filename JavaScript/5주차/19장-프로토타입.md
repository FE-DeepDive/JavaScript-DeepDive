자바스크립트는 **프로토타입** 기반의 객체지향 프로그래밍 언어입니다.

🏋️‍♀️ 드디어 `prototype`을 낱낱히 파헤쳐보는 시간을 가지겠습니다.

## 객체지향 프로그래밍

> 객체의 집합으로 프로그램을 표현하는 프로그래밍 패러다임입니다.

프로그래밍 패러다임은 프로그래머에게 프로그래밍의 👀관점을 갖게 해 주고, 결정하는 역할을 합니다.

-   **👵명령형 프로그래밍(imperative programming):** 프로그램을 명령어 또는 함수의 목록으로 바라봅니다.

-   **👧객체지향 프로그래밍 (object oriented programming):** 프로그램을 독립적인 객체의 집합으로 바라봅니다.

객체지향 프로그래밍은 우리가 세계를 인식하는 방식과 유사합니다.

예를 들어 봅시다.

🐈 어떤 고양이가 있다고 가정 해보죠.

이 고양이의 이름은 `Navi`이고 `3살`이며 `암컷`이라는 특징을 가지고 있다고 합시다.

어때요? 훨씬 전보다 어떤 고양이인지 구체적으로 이해가 잘 가시나요?

바로 이런 속성(이름,나이,성별 등)에 대한 정보들이 다른 고양이로부터 `Navi`를 구별할 수 있게 만들어주죠!

이 예시를 객체로 나타내면 다음과 같습니다.

```js
const cat = {
    name: 'Navi',
    age: 3,
    gender: 'female',
};
```

이처럼 우리 주변에 있는 실체(사물 or 개념)는 특징이나 성질을 나타내는 **속성(attribute / property)** 를 가지고 있습니다.

이 속성을 통해서 우리는 서로 다른 실체를 인식하거나 구별할 수 있게 되는 것이죠.

물론, 고양이에게는 다양한 속성이 존재할겁니다. 하지만 우리는 고양이의 `이름`과 `나이` `성별`에만 집중하겠다는 것이죠.

이렇게 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 표현하는 것을 `추상화(Abstract)`라고 합니다.

이처럼 객체지향 프로그래밍은 **독립적인 객체의 집합으로 프로그램을 표현**하려고 합니다.

이번에는 원이라는 개념을 객체로 만들어보죠. ⭕️

원에는 `반지름` 이라는 속성을 가지고있고 이 속성을 이용해서 `지름,둘레,넓이`를 구할 수 있습니다.

이때 반지름은 원의 **상태를 나타내는 데이터**이며, 지름 둘레 넓이를 구하는 행위는 **동작**이라고 생각할 수 있습니다.

```js
const circle = {
    radius: 8, // 원의 상태 데이터

    // 원의 지름
    getDiameter: function () {
        return this.radius * 2;
    },
    //원의 둘레
    getRound: function () {
        return Math.floor(this.radius * 2 * Math.PI);
    },
    // 원의 넓이
    getArea: function () {
        return Math.floor(this.radius ** 2 * Math.PI);
    },
};

console.log(circle); // {radius: 8, getDiameter: ƒ, getRound: ƒ, getArea: ƒ}

console.log(circle.getDiameter()); // 16
console.log(circle.getRound()); // 50
console.log(circle.getArea()); // 201
```

이처럼 객체 지향 프로그래밍은 객체의 **상태(state)** 를 나타내는 데이터와 상태 데이터를 조작할 수 있는 **동작(behavior)** 을 <u>하나의 논리적인 단위로 묶어서 </u>생각합니다.

그러면 이런 객체들이 서로 🔗관계성(relationship)을 맺을 수 있다면 굉장히 유용하지 않을까요?

실제로 객체는 다른 객체와 데이터를 주고 받거나, 또는 다른 객체의 상태 데이터나 동작을 **상속** 받아 사용할 수도 있습니다.

과연 이 상속이란 의미는 프로그래밍에서 어떤 의미일까요?

<br>

## 상속과 프로토타입

> 자바스크립트는 프로토타입을 기반으로 상속을 구현합니다.

**상속**이란 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속👇받아 그대로 사용할 수 있는 것을 의미합니다.

우선 17장에서 살펴본 생성자 함수를 한 번 복습해보죠.

```js
function Wizard(attack) {
    // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킵니다.
    this.attack = attack;
    this.specialAttack = function () {
        return this.attack * 2;
    };
}

// 인스턴스를 생성합니다.
const wizard1 = new Wizard(2); // 공격력이 2인 Wizard 객체를 생성합니다.
const wizard2 = new Wizard(5); // 공격력이 5인 Wizard 객체를 생성합니다.

// ❗️모든 인스턴스가 specialAttack이라는 메서드를 중복 생성하고 중복 소유합니다.
console.log(wizard1.specialAttack === wizard2.specialAttack); // false

console.log(wizard1.specialAttack()); // 4
console.log(wizard2.specialAttack()); // 10
```

만약 상속이 없다면 없다면 모든 인스턴스가 메서드를 중복 소유하게 되어 불필요한 메모리 낭비가 생길 것입니다.

예를 들어 10개의 인스턴스를 생성하면 내용이 같은 메서드도 10개 생성될테니까요! 😥

같은 내용이라면 메서드를 단 하나만 생성하여 서로 공유하는게 낫지 않을까요?

이처럼 상속을 구현하면 이런 불필요한 중복을 제거하는데 아주 효과적이겠죠!

상속을 구현하는 방법에는 여러가지가 있을 수 있지만, 자바스크립트는 **프로토타입(prototype)** 이라는 녀석을 기반으로 상속을 구현합니다.

```js
function Wizard(attack) {
    this.attack = attack;
}

// 모든 인스턴스가 이 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가합니다.
Wizard.prototype.specialAttack = function () {
    return this.attack * 2;
};

// 인스턴스를 생성합니다.
const wizard1 = new Wizard(2); //
const wizard2 = new Wizard(5); //

// ✅모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Wizard.prototype으로부터 specialAttack이라는 메서드를 상속받습니다.
console.log(wizard1.specialAttack === wizard2.specialAttack); // true

console.log(wizard1.specialAttack()); // 4
console.log(wizard2.specialAttack()); // 10
```

<br>

## 프로토타입 객체

> 프로토타입이란 어떤 객체의 상위(부모) 객체의 역할을 하는 객체입니다.

`[[Prototype]]`에 저장되는 프로토타입은 객체 생성 방식에 의해 결정됩니다.

뒤에 나올 내용이지만, 객체 리터럴에 의해 생성된 객체의 프로토타입은 `Object.prototype`이고,

생성자 함수에 의해 생성된 객체의 프로토타입은 `생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체`입니다.

모든 객체는 하나의 프로토타입을 가지며, 모든 프로토타입은 **생성자 함수와 연결**되어 있습니다.

아래 그림처럼 말이죠.

<img src="../img/chapter19/constructor_prototype_object.jpeg">

위 그림을 글로 정리해보겠습니다.

✅ 인스턴스는 `__proto__` 접근자 프로퍼티를 통해해 자신의 프로토타입에 간접적으로 접근할 수 있습니다.

✅프로토타입은 자신의 `constructor` 프로퍼티를 통해 생성자 함수에 접근할 수 있습니다.

✅생성자 함수는 자신의 `prototype` 프로퍼티를 통해 프로토타입에 접근할 수 있습니다.

#### `__proto__` 접근자 프로퍼티

-   `__proto__`는 **접근자 프로퍼티**입니다.

    기억하시겠지만, 접근자 프로퍼티는 자체적으로 값을 갖지는 않습니다.

    <br>

    이것은 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수, 즉 `[[Get]]` `[[Set]]` 프로퍼티 어트리뷰틀 구성된 프로퍼티입니다.

    ```js
    const obj = {};
    const parent = { a: 1 };

    // getter 함수인 get __proto__가 호출되어 obj 객체의 프로타타입을 취득합니다. (접근)
    obj.__proto__;

    // // setter 함수인 set __proto__가 호출되어 obj 객체의 프로타타입을 교체합니다. (할당)
    obj.__proto__ = parent;

    console.log(obj.a); // 1
    ```

<br>

-   `__proto__`는 객체가 직접 소유하는 프로퍼티가 아니라 **Object.prototype**의 프로퍼티입니다.

<br>

-   `__proto__`를 사용하는 이유는 **상호 참조에 의해 프로토타입 체인이 생성되는 것을 🚫방지하기 위함**입니다.

참고로 `__proto__` 접근자 프로퍼티 대신 프로토타입 참조를 취득하고 싶은 경우에는 `Object.getPrototypeOf` 를 사용하고

프로토타입을 교체하고 싶은 경우에는 `Object.setPropertyOf` 메서드를 사용할 것을 권장한다고 하네요.

#### 함수 객체의 prototype 프로퍼티

> 함수 객체만 소유하고 있으며, 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킵니다.

<br>

## 프로토타입의 생성 시점

> 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성됩니다.

생성자 함수는 크게 두 가지로 구분할 수 있습니다.

-   사용자가 직접 정의한 `사용자 정의 생성자 함수`
-   자바스크립트가 기본 제공하는 `빌트인 생성자 함수`

#### ⏰ 사용자 정의 생성자 함수와 프로토타입 생성 시점

> 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입이 생성됩니다.

prototype은 당연히 생성자 함수로서 호출할 수 있는 함수(함수 선언문 or 함수 표현식)인 `constructor`만 생성이되겠죠.

```js
// 화살표 함수로 정의한 함수는 non-constructor입니다.
const Cat = (name) => {
    this.name = name;
};

// 따라서 프로토타입이 생성되지 않습니다.
console.log(Cat.prototype); // undefined
```

예시를 살펴보죠.

```js
// 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성됩니다.
console.log(Cat.prototype); // {constructor: ƒ}

// 생성자 함수
function Cat(name) {
    this.name = name;
}
```

함수 선언문 같은 경우 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되는 것 기억하시나요?

그리고 이 때 평가되어 함수 객체를 생성되었죠.

그래서 함수 선언문 같은 경우도 런타임 이전에 프로토타입이 더불어서 생성됩니다.

함수 표현식은 또 다르겠죠? 아마도 함수 표현식은 런타임에 프로토타입이 더불어서 생성될 것입니다.

#### ⏰ 빌트인 생성자 함수와 프로토타입 생성 시점

> 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성됩니다.

빌트인 생성자 함수의 예시는 다음과 같습니다.

-   `Object`
-   `String`
-   `Number`
-   `Function`
-   `Array`
-   `RegExp`
-   `Date`
-   `Promise`

<br>

## 객체 생성 방식과 프로토타입의 결정

> 프로토타입은 OrdinaryObjectCreate에 전달되는 인수에 의해 결정됩니다.

모든 객체 생성 방식은 추상 연산 `OrdinaryObjectCreate`에 의해 생성됩니다.

추상 연산 `OrdinaryObjectCreate`는 <u>필수적으로</u> **자신이 생성할 객체의 프로토타입을 인수로 전달 받습니다.**

또한 자신이 생성할 객체에 추가할 프로퍼티 목록을 <u>옵션으로</u> 전달 받습니다.

조금 더 상세하게 설명드리겠습니다.

-   1.  OrdinaryObjectCreate는 빈 객체를 생성합니다.
-   2.  객체에 추가할 프로퍼티 목록이 인수로 전달된 경우에는 프로퍼티를 객체에 추가합니다.
-   3.  인수로 전달받은 프로토타입을 자신이 생성한 객체의 `[[Prototype]]` 내부 슬롯에 할당한 다음 생성된 객체를 반환 합니다.

자 이제 케이스를 나눠서 살펴보시죠.

✅ **객체 리터털**에 의해 생성된 객체의 프로토타입

> 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 **Object.prototype** 입니다.

따라서 객체 리터럴에 의해 생성되는 객체의 프로토타입은 `Object.prototype` 입니다.

<br>

✅ **Object 생성자 함수**에 의해 생성된 객체의 프로토타입

> 마찬가지로 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 **Object.prototype** 입니다.

따라서 Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 `Object.prototype` 입니다.

<br>

✅ **생성자 함수**에 의해 생성된 객체의 프로토타입

> 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 **생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체**입니다.

따라서 생성자 함수에 의해 생성되는 객체의 프로토타입은 `생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체` 입니다.

<br>

## 프로토타입 체인

> 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘입니다.

핵심 원리는 다음과 같습니다.

자바스크립트는 객체의 프로퍼티 접근할 때 해당 객체에 <u>접근하려는 프로퍼티가 없다면</u> **`[[Prototype]]` 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입 프로퍼티를 순차적으로 검색합니다.**

이것이 프로토타입 체인입니다. 예시를 통해서 같이 보시죠.

```js
function Cat(name) {
    this.name = name;
}

Cat.prototype.cry = function () {
    console.log(`Meow! my name is ${this.name}`);
};

const cat1 = new Cat('Navi');

// cat1 객체는 Object.prototype의 메서드인 hasOwnProperty를 호출할 수 있습니다.
console.log(cat1.hasOwnProperty('name')); // true
```

이처럼 cat1 객체가 `Cat.prototype`뿐 아니라 `Object.prototype`도 상속받았다는 것을 의미합니다.

이것은 cat1 객체가 프로토타입 체인을 따라 `hasOwnProperty` 메서드를 검색하여 사용할 수 있음을 의미합니다.

또 다른 예시를 보죠.

```js
function Ultra() {}
Ultra.prototype.ultraProp = 'Im from Ultra';

function Super() {}
Super.prototype = new Ultra();

function Sub() {}
Sub.prototype = new Super();

const obj = new Sub();

// obj는 ultraProp이라는 프로퍼티를 Ultra로 부터 상속 받았음을 알 수 있습니다.
console.log(obj.ultraProp); // 'Im from Ultra'
```

프로토타입 체인의 최상위에 위치하는 객체는 **Object.prototype**입니다.

그래서 Object.prototype을 프로토타입 체인의 종점이라고도 합니다. (end of prototype chain)

참고로 Object.prototype의 프로토타입은 `null` 입니다.

프로토타입 체인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우에는 **❗️undefined**를 반환 합니다.

<br>

## 오버라이딩과 프로퍼티 섀도잉

> 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가합니다.

이처럼 상속 관계에 의해 프로퍼티가 가려지는 현상을 `프로퍼티 섀도잉`이라고 합니다.

<br>

## instance 연산자

> 생성된 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인합니다.

```js
function Cat(name) {
    this.name = name;
}

const cat1 = new Cat('Navi');

// Cat.prototype이 cat1 객체의 프로토타입 체인 상에 존재합니다.
console.log(cat1 instanceof Cat); // true

// Object.prototype이 cat1 객체의 프로토타입 체인 상에 존재합니다.
console.log(cat1 instanceof Object); // true
```

<br>

## 직접 상속

직접 상속을 구현하는 방법은 두 가지가 있습니다.

-   `Object.create`에 의한 직접 상속
-   객체 리터럴 내부에서 `__proto__`에 의한 직접 상속

```js
// ES6에 도입된 __proto__ 접근자 프로퍼티를 사용한 직접 상속

const myProto = { a: 10 };

const obj = {
    b: 30,
    __proto__: myProto, // 객체를 직접 상속 받습니다.
};

console.log(obj.a, obj.b); // 10 30

console.log(Object.getPrototypeOf(obj) == myProto); // true
```

<br>

## 정적 프로퍼티 / 메서드

> 정적 프로퍼티 / 메서드는 생성자 함수가 생성한 인스턴스로 참조, 호출 할 수 없습니다.

<br>

## 프로퍼티 존재 확인

크게 두 가지가 있습니다.

-   `in 연산자`
-   `Object.prototype.hasOwnProperty`

참고로 객체 고유의 프로퍼티 키인지 아닌지를 확인하려면 `Object.prototype.hasOwnProperty`를 사용하는 것이 좋습니다.

<br>

## 프로퍼티 열거

프로퍼티를 열거하는 방법에는 두 가지가 있습니다.

-   `for...in` 문 사용
-   `Object.keys/values/entries` 메서드 사용

`for...in` 문은 객체 **자신의 고유프로퍼티 + 상속 받은 프로퍼티를 열거**합니다.

반면에 객체 **자신의 고유 프로퍼티만 열거**하려면 `Object.keys/values/entries` 메서드를 사용하는 것이 권장됩니다.

```js
const person = {
    name: 'Kim',
    address: 'Seoul',
    __proto__: { age: 19 },
};

console.log(Object.keys(person)); //  ['name', 'address']

console.log(Object.values(person)); //  ['Kim', 'Seoul']

console.log(Object.entries(person)); // [['name', 'address'],['Kim', 'Seoul']]
```
