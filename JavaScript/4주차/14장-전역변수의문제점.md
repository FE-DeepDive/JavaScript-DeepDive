## 01. 변수의 생명 주기

> 변수는 자신이 선언된 위치에서 생성되고 소멸합니다.

그래서 `전역 변수`는 **어플리케이션의 생명 주기와 동일** 합니다.

반면, 함수에 내부에 선언된 `지역 변수`는 **함수가 호출되면 생성되고 함수가 종료되면 소멸**합니다.

그렇다면 이렇게 변수의 생명 주기가 필요한 이유는 무엇일까요?

변수가 만약에 생명 주기를 가지지 않는다면, 한번 선언된 변수는 프로그램을 종료할 때까지 메모리 공간에 남아있게 되기 때문에 좋지 않습니다.

지역 변수와 전역 변수의 생명 주기를 자세하게 나눠서 살펴보도록 합시다.

이번에도 `let`, `const` 가 아닌 `var` 키워드를 코드에 사용하겠습니다.

### 지역 변수의 생명 주기

> 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 동일합니다.

```js
function foo() {
    var a = 'local';
    console.log(a); // local
    return a;
}

foo();
console.log(a); // ReferenceError: a is not defined
```

여기서 퀴즈를 내드리겠습니다. 과연 변수 a의 선언문은 런타임 이전에 실행될까요?

정답은 런타임 이전에 실행이 아니라, `함수 호출 이후`에 변수 a의 선언문이 실행 됩니다.

만약 변수 a가 전역 변수였다면 선언문이 런타임 이전에 실행되는 것이 맞습니다.

그러나 함수 내부에서 선언한 변수는 **함수가 호출된 직후**에 코드가 한줄씩 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행됩니다.

조금 더 자세하게 과정을 설명드려보겠습니다.

우선 foo 함수를 호출하면 함수 몸체의 다른 문들이 실행되기 이전에 a의 변수 선언문이 자바크립트 엔진에 의해 가장 먼저 실행되어 a변수가 선언되고 undefined가 초기화 됩니다.

그 이후 함수 몸체 내부의 문들이 순차적으로 실행되고 변수 할당문이 실행되면 a 변수에 값이 할당 됩니다.

그리고 함수가 종료되면 a 변수도 소멸되어 생명 주기가 종료 됩니다.

⚠️ But 항상 지역 변수의 생명 주기가 함수의 생명 주기가 동일한 것은 아닙니다.

가령, 지역 변수가 함수보다 오래 생존하는 경우도 존재합니다.

결론부터 말씀 드리면 **누군가 스코프를 참조하고 있으면 그 스코프는 소멸하지 않고 생존해 있게 됩니다.**

왜냐하면 **누군가가 메모리 공간을 참조하고 있으면 가비지 콜렉터에 의해 해제되지 않고 확보된 상태로 남아 있기 때문이죠.**

(참고로 가비지 콜렉터는 할당된 메모리 공간을 그 누구도 참조하고 있지 않을 때 해제하여 가용 메모리 풀에 반환합니다. 그래서 변수의 생명 주기도 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리 풀에 반환될 때 까지 입니다.)

```js
function test() {
    const obj = {
        x: 1,
    };
    return function test2() {
        console.log(obj.x);
    };
}

const a = test();

// 우리는 클로저라는 개념을 통해서 x라는 프로퍼티에 접근할 수 있습니다.
// 원래라면 test 함수의 생명 주기는 return 이후 사라지지만,
// test2가 test의 스코프를 참조하고 있기 때문에 test의 지역변수에 접근이 가능합니다.
a(); // 1
```

### 전역 변수의 생명 주기

`var` 키워드로 선언한 전역 변수는 <u>전역 객체(global object)</u>의 프로퍼티가 됩니다.

그래서 `var` 키워드의 경우 *전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치*하게 됩니다.

❗️그렇다면 전역 객체란 무엇일까요?

전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 다른 객체보다도 가장 먼저 생성되는 특수한 객체입니다.

전역 객체는 브라우저(클라이언트 사이드 환경)에서는 `window`, Node.js(서버 사이드 환경)에서는 `global` 객체를 의미합니다.

정리하자면 var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 됩니다.

전역 객체 window는 웹 페이지를 닫기 전까지 유효하기 때문에, **var 키워드로 선언한 전역 변수도 웹 페이지를 닫을 때까지 유효**하게 됩니다.

```js
var a = 'Jung Hee';

console.log(window.a); //"Jung Hee"
```

✋ 주의 할 점이 있네요. 참고로 `let` , `const` 키워드의 경우에는 window 객체의 프로퍼티로 추가되지 않습니다.

```js
var a = 'apple';
console.log(window.a); //"apple"

let b = 'banana';
console.log(window.b); //undefined

const c = 'strawberry';
console.log(window.c); //undefined
```

<br>

## 02. 전역 변수의 문제점

> 전역 변수는 상태 변경의 위험이 높고 메모리 리소스도 오랜 기간 소비합니다.

구체적인 용어와 함께 설명하겠습니다.

-   **암묵적 결합 (implicit coupling)**

    암묵적 결합이란 `모든 코드가 전역 변수를 참조하고 변경할 수 있음`을 말합니다.
    이것은 의도치 않게 상태 변경의 위험이 높아지게 됩니다.

<br>

-   **긴 생명 주기**

    생명 주기가 길기 때문에 메모리 리소스도 오랜 기간 소비하며 상태 변경의 기회도 많아지게 됩니다.

<br>

-   **스코프 체인 상에서 종점에 존재**

    전역 변수가 변수를 검색할 때 가장 마지막에 검색 됩니다. 다시 말해서 전역 변수의 검색 속도가 가장 느립니다.

<br>

-   **네임스페이스 오염**

    파일이 분리되어 있다 해도 전역 스코프를 공유하기 때문에 다른 파일 내에서 동일한 이름으로 명명된 전역 변수 혹은 전역 함수가 같은 스코프 내에 존재하게 됩니다.

<br>

따라서 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 `지역 변수`를 사용해야 합니다.

<br>

## 03. 전역 변수 사용을 억제하는 방법

#### 즉시 실행 함수

> 모든 코드를 즉시 실행 함수로 감싸서 모든 변수를 지역 변수가 되게 만드는 방법입니다.

```js
var secretUser = ['John', 'Mike', 'Tony'];

console.log(secretUser);
```

만약 위와 같은 방법을 쓴다면 보안이 좋지 않을 것이고 조작이 될 가능성이 높습니다.

왜냐하면 전역 변수로 선언이 되어있기에 금방 변수를 찾아내서 조작할 위험이 있기 때문이죠.

이를 막기 위해서 즉시 실행 함수를 활용합니다.

```js
(function () {
    var secretUser = ['John', 'Mike', 'Tony']; // ['John', 'Mike', 'Tony']
    console.log(secretUser); //
})();

// 접근이 불가합니다.
console.log(secretUser); // 🚫 ReferenceError: secretUser is not defined
```

<br>

#### 네임스페이스 객체

> 전역에 네임스페이스 역할을 담당할 객체를 생성하는 방법입니다.

```js
var MYAPP = {};

MYAPP.name = 'Kim';

console.log(MYAPP.name); // Kim
```

❗️But! 네임스페이스 객체 자체가 전역 변수에 할당되므로 사실상 유용하지 않다고 하네요...🫠

<br>

#### 모듈 패턴

> 전체 어플리케이션의 일부를 독립된 코드로 분리하여 만들어 놓은 것입니다.

책에 나온 방법은 클래스를 모방해서 관련 있는 전역 변수와 함수를 즉시 실행 함수로 감싸서 하나의 모듈을 만드는 방법입니다.

클래스는 새로운 객체를 생성하는 메커니즘이라고 일단 알아 둡시다.

이 방법은 `전역 변수의 억제`와 동시에 `캡슐화(encapsulation)`까지 구현 할 수 있는 장점이 있습니다.

✅ **캡슐화(encapsulation):** 객체의 상태를 나타내는 프로퍼티와 프로퍼티 참조하고 조작할 수 있는 동작 메서드를 하나로 묶는 것을 말합니다.
✅ **정보 은닉(information hiding):** 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 것을 말합니다.

모듈을 구현하는 가장 쉬운 방법은 객체 리터럴을 사용하는 방법입니다.

```js
var Counter = {
    num: 0,
    increase: function () {
        return ++this.num;
    },
    decrease: function () {
        return --this.num;
    },
};

console.log(Counter.num); // 0
console.log(Counter.increase()); // 1
console.log(Counter.decrease()); // 0
```

하지만 위와 같이 작성했을 경우 보안에 취약합니다.

그래서 아래와 같이 작성합니다.

```js
var Counter = (function () {
    // 은닉해야할 변수
    var num = 0;

    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환합니다.
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        },
    };
})();

// 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

<br>

다음은 또 다른 예시입니다.

```js
// 1. 네임스페이스를 설정하고 모듈을 정의
var MyApp = {}; // 전역 객체
MyApp.modules = {};

/*
 2. 공개범위(특권메소드 등..)와 비공개 유효범위를 만든다
 ==> 즉시 실행함수로 모듈이 될 객체를 반환하고
 모듈 사용자에게 제공할 공개 인터페이스가 담기게 된다.
 */
MyApp.modules.libs = (function () {
    // 비공개 프로퍼티
    // var 선언 및 비공개 메소드등의 유효범위 (private 멤버)

    // 공개 API  (public, previlege 멤버)
    return {};
})();
```

<br>

#### ES6 모듈

> script 태그에 type="module" 어트리뷰트를 추가하는 방식입니다.

ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없습니다.

왜냐하면 **ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공**하기 때문입니다.

그래서 이 방법을 사용하면 `var` 키워드로 선언한 변수는 더 이상 전역 변수도 아니며, window 객체의 프로퍼티도 아니게 됩니다.

```js
<script type="module" src="lib.mjs"> </script>
<script type="module" src="app.mjs"> </script>

```

❗️ 그러나 구형 브라우저에서는 동작하지 않으며, 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 더 일반적이라고 하네요.
